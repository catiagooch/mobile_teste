"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SauceConnectManager = void 0;
var _constants = require("./constants");
var _sauceConnectHealthcheck = _interopRequireDefault(require("./sauceConnectHealthcheck"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class SauceConnectManager {
  constructor(cp, logger, healthcheck) {
    this.cp = cp;
    this.logger = logger || (() => {});
    this.healthcheck = healthcheck || new _sauceConnectHealthcheck.default();
    this._healthcheckInterval = null;
    this._readyTimeout = null;
  }
  waitForReady(apiAddress) {
    let lastHealthcheckErr = null;
    apiAddress = this._parseApiAddress(apiAddress);
    return new Promise((resolve, reject) => {
      this.cp.stderr.on('data', data => {
        const output = data.toString();
        return reject(new Error(output));
      });
      this.cp.stdout.on('data', data => {
        const logger = this.logger;
        if (typeof logger === 'function') {
          logger(data.toString());
        }
      });
      this._healthcheckInterval = setInterval(async () => {
        if (this.cp.exitCode !== null && this.cp.exitCode !== undefined) {
          clearInterval(this._healthcheckInterval);
          clearTimeout(this._readyTimeout);
          return reject(new Error('Sauce Connect exited before reaching a ready state'));
        }
        this.healthcheck.perform(apiAddress).then(() => {
          clearInterval(this._healthcheckInterval);
          clearTimeout(this._readyTimeout);
          resolve();
        }).catch(err => {
          lastHealthcheckErr = err;
        });
      }, _constants.SC_HEALTHCHECK_TIMEOUT);
      this._readyTimeout = setTimeout(() => {
        var _lastHealthcheckErr, _lastHealthcheckErr2;
        clearInterval(this._healthcheckInterval);
        console.error(`Timeout waiting for healthcheck endpoint, err=${(_lastHealthcheckErr = lastHealthcheckErr) === null || _lastHealthcheckErr === void 0 ? void 0 : _lastHealthcheckErr.message}, code=${(_lastHealthcheckErr2 = lastHealthcheckErr) === null || _lastHealthcheckErr2 === void 0 ? void 0 : _lastHealthcheckErr2.code}`);
        reject(lastHealthcheckErr || new Error('Timeout waiting for healthcheck endpoint'));
      }, _constants.SC_READY_TIMEOUT);
    });
  }
  close() {
    this.logger('Terminating Sauce Connect...');
    return new Promise(resolve => {
      if (this.cp.exitCode !== null && this.cp.exitCode !== undefined) {
        return resolve();
      }
      const timeout = setTimeout(() => {
        this.logger('Forcefully terminating Sauce Connect...');
        killSilently(this.cp.pid, 'SIGKILL');
        resolve();
      }, _constants.SC_CLOSE_TIMEOUT);
      this.cp.on('exit', () => {
        clearTimeout(timeout);
        resolve();
      });
      clearInterval(this._healthcheckInterval);
      clearTimeout(this._readyTimeout);
      killSilently(this.cp.pid, 'SIGINT');
    });
  }
  _parseApiAddress(value) {
    const [host, port] = value.split(':');
    return `http://${host || 'localhost'}:${port}`;
  }
}
exports.SauceConnectManager = SauceConnectManager;
function killSilently(pid, signal) {
  try {
    process.kill(pid, signal);
  } catch (err) {
    // ignore
  }
}